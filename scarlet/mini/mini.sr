true IS UNIQUE AS_LANGUAGE_ITEM(true)
false IS UNIQUE AS_LANGUAGE_ITEM(false)
void IS UNIQUE AS_LANGUAGE_ITEM(void)

true AS_LANGUAGE_ITEM(and)
true AS_LANGUAGE_ITEM(trivial_t_statement)
true AS_LANGUAGE_ITEM(invariant_truth_t_statement)
true AS_LANGUAGE_ITEM(invariant_truth_rev_t_statement)
true AS_LANGUAGE_ITEM(eq_ext_rev_t_statement)
true AS_LANGUAGE_ITEM(inv_eq_t_statement)
# true AS_LANGUAGE_ITEM(refl_t_statement)
# true AS_LANGUAGE_ITEM(decision_eq_t_statement)
# true AS_LANGUAGE_ITEM(decision_neq_t_statement)
# true AS_LANGUAGE_ITEM(decision_identity_t_statement)

{
    has_tail IS BUILTIN_FUNCTION(has_tail)
    x IS VAR() AS_LANGUAGE_ITEM(x)
    y IS VAR() AS_LANGUAGE_ITEM(y)

    when_equal IS 
    VAR() AS_LANGUAGE_ITEM(when_equal)

    when_not_equal IS 
    VAR() AS_LANGUAGE_ITEM(when_not_equal)
}

tail IS BUILTIN_FUNCTION(tail_value)

predicate_t IS tail({
   y IS VAR()
   statement_when_equal IS VAR(SELF DEP z)
   z IS VAR(y)

   statement IS statement_when_equal
   AS_LANGUAGE_ITEM(cases_t_statement)

   AXIOM(cases_t)
})

void_from_false_t IS tail({
    assume_false IS VAR(false)

    statement IS tail({assume_false = void})
    AS_LANGUAGE_ITEM(refl_t_statement)
    
    AXIOM(refl_t)
})

# predicate_t SHOWN

assumption IS VAR(false)
conclusion IS false = void
void_from_false_t(false)

predicate_t(false conclusion)
SHOWN
